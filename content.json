{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Test","text":"some thing","link":"/2019/10/31/first-artic/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/31/hello-world/"},{"title":"深入理解synchronized","text":"使用方式 synchronized有如下三种使用方式: 静态方法上加关键字，锁的是当前对象 普通方法（实例方法）上加关键字，锁的是当前Class对象 同步代码块 synchronized()，锁的是括号中的对象 可以看到，synchronized锁的维度有两种： 1、类2、实例对象 那么对于不同的使用方式，在不同的维度上进行加锁的操作，其内部的实现原理是否有不同之处，以及具体是如何实现的，继续深入了解。 深入原理 首先看以下代码： 1234567891011public class Sync { public synchronized void methodA(){ } public void methodB(){ synchronized (this){ } }} 通过命令javap -c Synchronize查看编译后的字节码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Last modified 2019-01-17; size 527 bytes MD5 checksum 2634f8850610507e7ced205bcd6243bc Compiled from &quot;Sync.java&quot;public class com.example.demo.sync.Sync minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#19 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #20 // com/example/demo/sync/Sync #3 = Class #21 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lcom/example/demo/sync/Sync; #11 = Utf8 methodA #12 = Utf8 methodB #13 = Utf8 StackMapTable #14 = Class #20 // com/example/demo/sync/Sync #15 = Class #21 // java/lang/Object #16 = Class #22 // java/lang/Throwable #17 = Utf8 SourceFile #18 = Utf8 Sync.java #19 = NameAndType #4:#5 // &quot;&lt;init&gt;&quot;:()V #20 = Utf8 com/example/demo/sync/Sync #21 = Utf8 java/lang/Object #22 = Utf8 java/lang/Throwable{ public com.example.demo.sync.Sync(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/example/demo/sync/Sync; //methodA对应 public synchronized void methodA(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 this Lcom/example/demo/sync/Sync; //methodB对应 public void methodB(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: aload_1 5: monitorexit 6: goto 14 9: astore_2 10: aload_1 11: monitorexit 12: aload_2 13: athrow 14: return Exception table: from to target type 4 6 9 any 9 12 9 any LineNumberTable: line 9: 0 line 11: 4 line 12: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 this Lcom/example/demo/sync/Sync; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 9 locals = [ class com/example/demo/sync/Sync, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4}SourceFile: &quot;Sync.java&quot; 通过反编译的字节码信息，可以得知： 1、synchronized修饰方式时，通过在方法访问标识符（flags）上加入ACC_SYNCHRONIZED来实现同步功能。2、synchronized同步代码块时，在同步代码块的前后加入monitorenter和monitorexit指令来实现同步的功能。官方文档中对于这两种方法的说明：对于同步方法： Method-level synchronization is performed implicitly, as part of method invocation and return (§2.11.8). A synchronized method is distinguished in the run-time constant pool’s method_info structure (§4.6) by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method. 总结一下，即是： 方法级的执行方式是隐式的，通过在运行时常量池的method_info结构中通过ACC_SYNCHRONIZED标志加以区分。当调用设置了ACC_SYNCHRONIZED标志的方法时，无论方法调用是正常返回还是抛出异常，执行线程都会进入监视器，执行方法本身，并退出监视器。 而对于同步代码块，官方文档给出的说明： Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count. If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership. 简单说就是： 每个对象都会与一个monitor关联，当某个monitor被拥有后就会锁住，其他的线程执行到monitorenter指令时，通过计数器判断当前是否有其他线程占用锁。 不难看出，在JVM中每个对象拥有一个互斥锁，由JVM自动获取和释放，并且都是通过monitor来实现同步。同时，通过每个monitor都维护着一个计数器的方式来判断当前锁是否被占有，以及实现可重入的特性。 Monitor概念模型 Monitor被称为监视器或者管程。在JAVA相关的概念中很多时候用监视器来表示这个概念，但是在操作系统领域中更多的时候被翻译为管程，为了避免混淆，下文将沿用管程来代表Monitor。在操作系统的概念中，管程类型提供了一组自定义的、在管程内互斥的操作，同时管程结构确保了同时只能有一个进程在其内部活动。以下来自wiki百科： 一个管程包含： 多个彼此可以交互共享资源的线程 多个与资源使用有关的变量 一个互斥锁 一个用来避免竞态条件的不变量 一个管程的程序在运行一个线程前会先获取互斥锁，直到完成线程或是线程等待某个条件被满足才会放弃互斥锁。若每个执行中的线程在放弃互斥锁之前都能保证不变量成立，则所有线程皆不会导致竞态条件成立。 大致了解了管程的概念，对应的来看看JAVA中对于管程概念模型的实现及流程。在JAVA中线程获取互斥锁-执行-释放的大致流程如下图所示：上文中提到，每个JAVA对象实例都会有一个Monitor，并且Monitor随着JAVA对象实例一起被创建和销毁（Moniotr在hotspot中的实现——objectMonitor.hpp）。结合上图，JAVA中多个线程访问一段同步的代码时，会先放在EntryList中，当线程获取到Monitor时，如果申请互斥锁（Mutex）成功，则持有该锁，否则进入WaitSet等待下一次唤醒。线程执行完成方法（或发生异常）后，释放锁，并唤醒WaitSet中的线程（如果有的话）。 Monitor依赖于底层操作系统的实现，存在用户态和内核态之间的切换，增加了性能开销，所以，使用synchronized关键字在并发中是一个相对比较重量级的操作。对此，JDK1.6之后的版本中对synchronized进行了优化，使其的使用效率得到了大幅度的提升。 Java对象头和Mark Word 了解synchronized的优化之前，先大致了解一下JAVA对象的内存模型、Java对象头和Mark Word。如图所示，一个对象在内存中包含了三个部分： 对象头 实例数据 对齐填充 对象头中的内容包含： Mark Word: 存储对象自身的运行时数据，比如HashCode、GC分代年龄、锁状态标志等。这部分在32位和64位的虚拟机中分别为32bit和64bit（以下均不考虑指针压缩的场景）。 Class Pointer: 指向对象对应的Class对象的元数据的指针，通过该指针来确定具体是哪一个类。这部分在32位和64位的虚拟机中分别为32bit和64bit。 Length：如果是一个数组对象，则还必须有一块用来储存数组长度，因为虚拟机可以通过对象的元数据来确定对象的大小，而从数组的元数据中无法确定数组对象的大小。这部分占32个bit。 Mark Word 由于Mark Word只有32位或64位，为了存储更多的信息，其结构会随着锁标志位的变化而变化：32bit 64bit 锁优化 简单了解了对象头和Mark Word的结构后，继续深入了解JVM中内置锁优化升级的相关概念。JDK1.6对Synchronized的实现进行了优化，引入偏向锁、轻量级锁、重量级锁、自旋锁，减少上下文切换以提升性能。 主要针对三种场景： 只有一个线程进入临界区：偏向锁 多线程交替执行或少量时间竞争执行同步块：轻量级锁 多线程长时间竞争执行同步块：重量级锁 Synchronized内置锁的膨胀过程为：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，并且锁只可以升级不可以降级。 偏向锁 偏向锁主要针对的场景：同一个线程多次申请同一个锁，即大部分时间内只有一个线程进入临界区。当一个线程再次访问同一块同步代码时，只需对该对象头的Mark Word中去判断是否有偏向锁指向该线程，如果是，则无需再进入Monitor竞争锁，减少了不必要的开销。偏向锁的获取过程： （1）确认可偏向状态：访问Mark Word中偏向锁的标志位是否位1，锁标志位是否为01（2）确认当前线程ID是否指向自己，是则执行（5），否则执行（3）（3）尝试CAS操作将线程ID替换为自己的线程ID，如果成功执行（5），否则执行（4）（4）CAS失败则表示存在有竞争，则撤销偏向锁（5）执行同步体 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。同时，撤销偏向锁需要等到全局安全点（即在这个时间点上没有正在执行的字节码）。 正如之前所提到的，偏向锁适合只有一个线程进入临界区的场景，是一个带有权衡效益性质的优化。如果程序中大多数的锁总是被不同的线程访问，通过参数-XX：UseBisaseLocking来禁止偏向锁，有时反而能够提升性能。 轻量级锁 轻量级锁适用于少量线程交替执行或者少量时间执行同步块的场景，由此可见，轻量级锁并不是用来替代重量级锁的，它的本意是在少量线程执行或者少量时间执行同步块的场景下，减少传统重量级锁使用产生的性能消耗。 轻量级锁的加锁过程： (1) 如果对象锁状态为无锁状态(01|0)，首先在当前的栈帧中创建Lock Record用于存储当前对象的mark word，称之为 Displaced Mark Word(2) 将Mark Word拷贝一份到Lock Record(3) 拷贝成功之后，虚拟机使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record 中onwer的指针指向object mark word。如果成功，执行（4），失败则执行（5）(4)如果更新成功，则这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位为00(5)如果更新失败，虚拟机首先会检查该对象的Mark Word是否指向当前线程的栈帧，如果是则说明当前线程已拥有了该对象的锁，可以直接进入同步块继续执行（即锁重入）；否则说明多个线程竞争锁，那么轻量级锁就要膨胀为重量级锁，锁标志位的值变为10，Mark Word中存储的就是指向重量级锁的指针，后边等待的线程进入阻塞状态。 轻量级锁解锁时，会通过CAS操作尝试将线程中复制的Displaced Mark Word替换为当前的Mark Word，如果成功则整个流程完成。如果失败，则说明有其他的线程尝试过获取锁，此时已膨胀为重量级锁，那么释放锁的同时会唤醒阻塞的线程。 自旋锁 在操作系统中，线程的阻塞和唤醒需要CPU从用户态切换为核心态，频繁的阻塞和环境对于CPU来说是一件负担很重的工作。如果说每个线程执行的时间都很短，那么对每个线程都进行阻塞和唤醒的动作是非常不值得的。JVM中通过引入自旋锁的方式处理这种场景。在轻量级锁的加锁过程中会通过CAS操作修改Mark Word，如果其他线程已获得锁，那么CAS操作失败，这个时候当前线程会进入自旋的状态，等待另一个线程执行完毕后获取锁进入同步区执行。自旋锁虽然解决了频繁切换线程带来的开销，但是自旋本质上是让线程执行一段循环，如果线程一直没有释放锁，还是会带来占用过多CPU时间的问题。所以自旋锁必须要有一个自旋的等待时间（自旋次数），如果超过时间还未获取到锁，则当前线程应当被挂起。在JDK1.6中自旋锁默认开启，同时默认的次数为10次，可以通过-XX:PreBlockSpin进行调整。 适应性自旋锁 自旋锁带来了避免线程占用过多CPU时间的好处，但是考虑如下场景：系统内很多线程都是刚刚退出的时候，其他线程就释放了锁，也就是说只要多循环几次就能获取锁。自旋锁的次数可以通过-XX:PreBlockSpin调整，但也不够灵活，所以在JVM1.6中引入了更加聪明的适应性自旋锁来解决这个问题。所谓适应性自旋锁意味着自旋的次数不再固定，它会由上一次锁的自旋时间及锁的拥有者的状态来决定。如果线程自旋成功了，那么虚拟机会认为再次自旋成功的概率更大，那么虚拟机就会增加自旋次数，允许自旋等待的持续时间更久；反之，如果某个锁很少能够自旋成功的，那么以后获取这个锁的时候自旋次数会减少甚至直接忽略掉自旋过程，以免浪费处理器资源。 锁消除与逃逸分析 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但有时候并没有存在共享数据竞争（竞态条件），JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析后得到的数据。关于逃逸分析的概念本文不过多展开，简单的说，逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可以被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。比如： 123456public static String craeteStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();} 以上代码在使用stringBuffer时，并没有将StringBUffer的实例返回。如果将sb返回，那么它虽然时个局部变量，但也有可能被其他的方法所调用，称其为逃逸到了方法外部；甚至还有可能被其他的线程所调用，比如赋值给类变量或可以在其他线程中访问的实例变量，称其为线程逃逸。上述代码只返回了sb.toString(),显然没有发生逃逸，不存在竞态条件，此时StringBuffer内部的加锁毫无意义，JVM可以大胆的将锁消除，以避免浪费无意义的请求锁的时间。 参考资料：[1]《深入理解java虚拟机》[2]《Java并发编程的艺术》[3]《Java并发编程实战》","link":"/2019/01/17/2019-01-17-JavaSynchronized/"}],"tags":[],"categories":[]}