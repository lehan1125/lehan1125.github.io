<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深入理解synchronized - Lehan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lehan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lehan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="关于Synchronized的使用及原理。"><meta property="og:type" content="blog"><meta property="og:title" content="深入理解synchronized"><meta property="og:url" content="https://lehan1125.github.io/2019/01/17/2019-01-17-JavaSynchronized/"><meta property="og:site_name" content="Lehan&#039;s Blog"><meta property="og:description" content="关于Synchronized的使用及原理。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.pexels.com/photos/355465/pexels-photo-355465.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500"><meta property="article:published_time" content="2019-01-17T11:33:21.000Z"><meta property="article:modified_time" content="2019-01-17T12:05:32.000Z"><meta property="article:author" content="Lehan"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images.pexels.com/photos/355465/pexels-photo-355465.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://lehan1125.github.io/2019/01/17/2019-01-17-JavaSynchronized/"},"headline":"深入理解synchronized","image":[],"datePublished":"2019-01-17T11:33:21.000Z","dateModified":"2019-01-17T12:05:32.000Z","author":{"@type":"Person","name":"Lehan"},"publisher":{"@type":"Organization","name":"Lehan's Blog","logo":{"@type":"ImageObject","url":{"text":"Lehan's blog"}}},"description":"关于Synchronized的使用及原理。"}</script><link rel="canonical" href="https://lehan1125.github.io/2019/01/17/2019-01-17-JavaSynchronized/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Lehan&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://images.pexels.com/photos/355465/pexels-photo-355465.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500" alt="深入理解synchronized"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-01-17T11:33:21.000Z" title="2019/1/17 下午7:33:21">2019-01-17</time>发表</span><span class="level-item"><time dateTime="2019-01-17T12:05:32.000Z" title="2019/1/17 下午8:05:32">2019-01-17</time>更新</span><span class="level-item">28 分钟读完 (大约4259个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">深入理解synchronized</h1><div class="content"><hr>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><hr>
<p><code>synchronized</code>有如下三种使用方式:</p>
<p><strong>静态方法</strong>上加关键字，锁的是<strong>当前对象</strong><br><strong>普通方法（实例方法）</strong>上加关键字，锁的是<strong>当前Class对象</strong><br><strong>同步代码块</strong> <code>synchronized()</code>，锁的是<strong>括号中的对象</strong><br>可以看到，<code>synchronized</code>锁的维度有两种：</p>
<p>1、类<br>2、实例对象</p>
<p>那么对于不同的使用方式，在不同的维度上进行加锁的操作，其内部的实现原理是否有不同之处，以及具体是如何实现的，继续深入了解。</p>
<hr>
<h1 id="深入原理"><a href="#深入原理" class="headerlink" title="深入原理"></a>深入原理</h1><hr>
<p>首先看以下代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>通过命令<code>javap -c Synchronize</code>查看编译后的字节码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Last modified 2019-01-17; size 527 bytes</span><br><span class="line">  MD5 checksum 2634f8850610507e7ced205bcd6243bc</span><br><span class="line">  Compiled from &quot;Sync.java&quot;</span><br><span class="line">public class com.example.demo.sync.Sync</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #20            // com/example/demo/sync/Sync</span><br><span class="line">   #3 = Class              #21            // java/lang/Object</span><br><span class="line">   #4 = Utf8               &lt;init&gt;</span><br><span class="line">   #5 = Utf8               ()V</span><br><span class="line">   #6 = Utf8               Code</span><br><span class="line">   #7 = Utf8               LineNumberTable</span><br><span class="line">   #8 = Utf8               LocalVariableTable</span><br><span class="line">   #9 = Utf8               this</span><br><span class="line">  #10 = Utf8               Lcom/example/demo/sync/Sync;</span><br><span class="line">  #11 = Utf8               methodA</span><br><span class="line">  #12 = Utf8               methodB</span><br><span class="line">  #13 = Utf8               StackMapTable</span><br><span class="line">  #14 = Class              #20            // com/example/demo/sync/Sync</span><br><span class="line">  #15 = Class              #21            // java/lang/Object</span><br><span class="line">  #16 = Class              #22            // java/lang/Throwable</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               Sync.java</span><br><span class="line">  #19 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #20 = Utf8               com/example/demo/sync/Sync</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">  #22 = Utf8               java/lang/Throwable</span><br><span class="line">&#123;</span><br><span class="line">  public com.example.demo.sync.Sync();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/demo/sync/Sync;</span><br><span class="line"></span><br><span class="line">  //methodA对应</span><br><span class="line">  public synchronized void methodA();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lcom/example/demo/sync/Sync;</span><br><span class="line"></span><br><span class="line">  //methodB对应</span><br><span class="line">  public void methodB();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter</span><br><span class="line">         4: aload_1</span><br><span class="line">         5: monitorexit</span><br><span class="line">         6: goto          14</span><br><span class="line">         9: astore_2</span><br><span class="line">        10: aload_1</span><br><span class="line">        11: monitorexit</span><br><span class="line">        12: aload_2</span><br><span class="line">        13: athrow</span><br><span class="line">        14: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             4     6     9   any</span><br><span class="line">             9    12     9   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 11: 4</span><br><span class="line">        line 12: 14</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      15     0  this   Lcom/example/demo/sync/Sync;</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 9</span><br><span class="line">          locals = [ class com/example/demo/sync/Sync, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Sync.java&quot;</span><br></pre></td></tr></table></figure>    
<p>通过反编译的字节码信息，可以得知：</p>
<p>1、<code>synchronized</code>修饰方式时，通过在方法访问标识符<code>（flags）</code>上加入<code>ACC_SYNCHRONIZED</code>来实现同步功能。<br>2、<code>synchronized</code>同步代码块时，在同步代码块的前后加入<code>monitorenter</code>和<code>monitorexit</code>指令来实现同步的功能。<br>官方文档中对于这两种方法的说明：<br>对于同步方法：  </p>
<blockquote>
<p>Method-level synchronization is performed implicitly, as part of method invocation and return (§2.11.8). A synchronized method is distinguished in the run-time constant pool’s method_info structure (§4.6) by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.  </p>
</blockquote>
<p>总结一下，即是：  </p>
<blockquote>
<p>方法级的执行方式是隐式的，通过在运行时常量池的<code>method_info</code>结构中通过<strong>ACC_SYNCHRONIZED</strong>标志加以区分。当调用设置了<strong>ACC_SYNCHRONIZED</strong>标志的方法时，无论方法调用是正常返回还是抛出异常，执行线程都会进入监视器，执行方法本身，并退出监视器。</p>
</blockquote>
<p>而对于同步代码块，官方文档给出的说明：</p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<ul>
<li>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li>
<li>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</li>
<li>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.  </li>
</ul>
</blockquote>
<p>简单说就是：  </p>
<blockquote>
<p>每个对象都会与一个<strong>monitor</strong>关联，当某个<strong>monitor</strong>被拥有后就会锁住，其他的线程执行到<strong>monitorenter</strong>指令时，通过计数器判断当前是否有其他线程占用锁。  </p>
</blockquote>
<p>不难看出，在<code>JVM</code>中每个对象拥有一个<strong>互斥锁</strong>，由<code>JVM</code>自动获取和释放，并且都是通过<code>monitor</code>来实现同步。同时，通过每个<code>monitor</code>都维护着一个<strong>计数器</strong>的方式来判断当前锁是否被占有，以及实现<strong>可重入</strong>的特性。</p>
<hr>
<h1 id="Monitor概念模型"><a href="#Monitor概念模型" class="headerlink" title="Monitor概念模型"></a>Monitor概念模型</h1><hr>
<p><code>Monitor</code>被称为<strong>监视器</strong>或者<strong>管程</strong>。在<code>JAVA</code>相关的概念中很多时候用监视器来表示这个概念，但是在操作系统领域中更多的时候被翻译为管程，为了避免混淆，下文将沿用管程来代表Monitor。<br>在操作系统的概念中，管程类型提供了一组自定义的、在管程内互斥的操作，同时管程结构确保了<strong>同时只能有一个进程</strong>在其内部活动。<br>以下来自wiki百科：  </p>
<blockquote>
<p>一个管程包含：  </p>
<ul>
<li>多个彼此可以交互共享资源的线程</li>
<li>多个与资源使用有关的变量</li>
<li>一个互斥锁</li>
<li>一个用来避免竞态条件的不变量</li>
</ul>
<p>一个管程的程序在运行一个线程前会先获取互斥锁，直到完成线程或是线程等待某个条件被满足才会放弃互斥锁。若每个执行中的线程在放弃互斥锁之前都能保证不变量成立，则所有线程皆不会导致竞态条件成立。  </p>
</blockquote>
<p>大致了解了管程的概念，对应的来看看<code>JAVA</code>中对于管程概念模型的实现及流程。在<code>JAVA</code>中线程获取<strong>互斥锁-执行-释放</strong>的大致流程如下图所示：<br><img src="https://s1.ax1x.com/2020/06/14/NSV0sK.png"><br>上文中提到，<strong>每个</strong><code>JAVA</code>对象实例都会有一个<code>Monitor</code>，并且<code>Monitor</code>随着<code>JAVA</code>对象实例<strong>一起</strong>被创建和销毁（Moniotr在hotspot中的实现——<a target="_blank" rel="noopener" href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp" title="objectMonitor.hpp">objectMonitor.hpp</a>）。结合上图，<code>JAVA</code>中多个线程访问一段同步的代码时，会先放在<code>EntryList</code>中，当线程获取到<code>Monitor</code>时，如果申请互斥锁（<code>Mutex</code>）成功，则持有该锁，否则进入<code>WaitSet</code>等待下一次唤醒。线程执行完成方法（或发生异常）后，释放锁，并唤醒<code>WaitSet</code>中的线程（如果有的话）。</p>
<p><code>Monitor</code>依赖于底层操作系统的实现，存在用户态和内核态之间的切换，增加了性能开销，所以，使用<code>synchronized</code>关键字在并发中是一个相对比较重量级的操作。对此，<code>JDK1.6</code>之后的版本中对<code>synchronized</code>进行了优化，使其的使用效率得到了大幅度的提升。  </p>
<hr>
<h1 id="Java对象头和Mark-Word"><a href="#Java对象头和Mark-Word" class="headerlink" title="Java对象头和Mark Word"></a>Java对象头和Mark Word</h1><hr>
<p>了解synchronized的优化之前，先大致了解一下JAVA对象的内存模型、Java对象头和Mark Word。<br><img src="https://s1.ax1x.com/2020/06/15/NpqLMn.jpg"><br>如图所示，一个对象在内存中包含了三个部分：  </p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p>对象头中的内容包含：</p>
<ul>
<li><strong>Mark Word</strong>: 存储对象自身的<strong>运行时数据</strong>，比如<strong>HashCode</strong>、<strong>GC分代年龄</strong>、<strong>锁状态标志</strong>等。这部分在<code>32</code>位和<code>64</code>位的虚拟机中分别为<code>32bit</code>和<code>64bit</code>（以下均不考虑指针压缩的场景）。</li>
<li><strong>Class Pointer</strong>: 指向对象对应的<strong>Class</strong>对象的<strong>元数据</strong>的指针，通过该指针来确定具体是哪一个类。这部分在<code>32</code>位和<code>64</code>位的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。</li>
<li><strong>Length</strong>：如果是一个<strong>数组对象</strong>，则还必须有一块用来储存<strong>数组长度</strong>，因为虚拟机可以通过对象的元数据来确定对象的大小，而从数组的元数据中无法确定数组对象的大小。这部分占<code>32</code>个<code>bit</code>。  </li>
</ul>
<hr>
<h1 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h1><hr>
<p>由于<strong>Mark Word</strong>只有<code>32</code>位或<code>64</code>位，为了存储更多的信息，其结构会随着锁标志位的变化而变化：<br>32bit</p>
<p>64bit</p>
<hr>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><hr>
<p>简单了解了对象头和<strong>Mark Word</strong>的结构后，继续深入了解<code>JVM</code>中内置锁优化升级的相关概念。<br><code>JDK1.6</code>对<code>Synchronized</code>的实现进行了优化，引入<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>、<strong>自旋锁</strong>，减少<strong>上下文切换</strong>以提升性能。</p>
<p>主要针对三种场景：</p>
<ul>
<li><strong>只有一个</strong>线程进入临界区：<strong>偏向锁</strong></li>
<li>多线程<strong>交替执行</strong>或<strong>少量时间</strong>竞争执行同步块：<strong>轻量级锁</strong></li>
<li>多线程<strong>长时间</strong>竞争执行同步块：<strong>重量级锁</strong></li>
</ul>
<p><code>Synchronized</code>内置锁的膨胀过程为：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，并且<strong>锁只可以升级不可以降级</strong>。  </p>
<hr>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><hr>
<p>偏向锁主要针对的场景：同一个线程<strong>多次</strong>申请同一个锁，即大部分时间内<strong>只有一个</strong>线程进入临界区。当一个线程<strong>再次</strong>访问同一块同步代码时，只需对该对象头的<code>Mark Word</code>中去判断是否有<strong>偏向锁</strong>指向该线程，如果是，则无需再进入<code>Monitor</code>竞争锁，减少了不必要的开销。<br>偏向锁的获取过程：</p>
<blockquote>
<p>（1）确认可偏向状态：访问<code>Mark Word</code>中偏向锁的标志位是否位1，锁标志位是否为01<br>（2）确认当前线程ID是否指向自己，是则执行<code>（5）</code>，否则执行<code>（3）</code><br>（3）尝试<strong>CAS</strong>操作将线程ID替换为自己的线程ID，如果成功执行<code>（5）</code>，否则执行<code>（4）</code><br>（4）<strong>CAS</strong>失败则表示存在有竞争，则撤销偏向锁<br>（5）执行同步体  </p>
</blockquote>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。同时，撤销偏向锁需要等到<strong>全局安全点</strong>（即在这个时间点上没有正在执行的字节码）。</p>
<p>正如之前所提到的，偏向锁适合<strong>只有一个</strong>线程进入临界区的场景，是一个带有<strong>权衡效益</strong>性质的优化。如果程序中大多数的锁总是被不同的线程访问，通过参数-XX：UseBisaseLocking来<strong>禁止</strong>偏向锁，有时反而能够提升性能。  </p>
<hr>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><hr>
<p>轻量级锁适用于少量线程<strong>交替</strong>执行或者<strong>少量时间</strong>执行同步块的场景，由此可见，轻量级锁<strong>并不是</strong>用来替代重量级锁的，它的本意是在少量线程执行或者少量时间执行同步块的场景下，减少传统重量级锁使用产生的性能消耗。  </p>
<p>轻量级锁的加锁过程：  </p>
<blockquote>
<p>(1) 如果对象锁状态为无锁状态(01|0)，首先在当前的栈帧中创建<strong>Lock Record</strong>用于存储当前对象的<strong>mark word</strong>，称之为 <strong>Displaced Mark Word</strong><br>(2) 将<strong>Mark Word</strong>拷贝一份到<strong>Lock Record</strong><br>(3) 拷贝成功之后，虚拟机使用<strong>CAS</strong>操作尝试将对象的<strong>Mark Word</strong>更新为指向<strong>Lock Record</strong>的指针，并将<strong>Lock Record</strong> 中<code>onwer</code>的指针指向<strong>object mark word</strong>。如果成功，执行<code>（4）</code>，失败则执行<code>（5）</code><br>(4)如果更新成功，则这个线程就拥有了该对象的锁，并且对象<strong>Mark Word</strong>的锁标志位为00<br>(5)如果更新失败，虚拟机首先会检查该对象的<strong>Mark Word</strong>是否指向<strong>当前线程</strong>的栈帧，如果是则说明当前线程已拥有了该对象的锁，可以直接进入同步块继续执行（即<strong>锁重入</strong>）；否则说明多个线程竞争锁，那么轻量级锁就要膨胀为重量级锁，锁标志位的值变为10，<strong>Mark Word</strong>中存储的就是指向重量级锁的指针，后边等待的线程进入阻塞状态。  </p>
</blockquote>
<p>轻量级锁解锁时，会通过<strong>CAS</strong>操作尝试将线程中复制的<strong>Displaced Mark Word</strong>替换为当前的<strong>Mark Word</strong>，如果成功则整个流程完成。如果失败，则说明有其他的线程尝试过获取锁，此时已膨胀为重量级锁，那么释放锁的同时会唤醒阻塞的线程。  </p>
<hr>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><hr>
<p>在操作系统中，线程的阻塞和唤醒需要CPU从用户态切换为核心态，频繁的阻塞和环境对于CPU来说是一件负担很重的工作。如果说每个线程执行的时间都很短，那么对每个线程都进行阻塞和唤醒的动作是非常不值得的。JVM中通过引入自旋锁的方式处理这种场景。<br>在轻量级锁的加锁过程中会通过<strong>CAS</strong>操作修改<strong>Mark Word</strong>，如果其他线程已获得锁，那么<strong>CAS</strong>操作失败，这个时候当前线程会进入<strong>自旋</strong>的状态，等待另一个线程执行完毕后获取锁进入同步区执行。<br>自旋锁虽然解决了<strong>频繁切换线程</strong>带来的开销，但是自旋本质上是让线程执行一段<strong>循环</strong>，如果线程一直没有释放锁，还是会带来占用过多<strong>CPU</strong>时间的问题。所以自旋锁必须要有一个自旋的<strong>等待时间</strong>（自旋次数），如果超过时间还未获取到锁，则当前线程应当被<strong>挂起</strong>。<br>在<code>JDK1.6</code>中自旋锁默认开启，同时默认的次数为<strong>10</strong>次，可以通过<code>-XX:PreBlockSpin</code>进行调整。 </p>
<hr>
<h1 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h1><hr>
<p>自旋锁带来了避免线程占用过多CPU时间的好处，但是考虑如下场景：系统内很多线程都是刚刚退出的时候，其他线程就释放了锁，也就是说只要<strong>多循环几次</strong>就能获取锁。自旋锁的次数可以通过<code>-XX:PreBlockSpin</code>调整，但也不够灵活，所以在<code>JVM1.6</code>中引入了更加聪明的<strong>适应性自旋锁</strong>来解决这个问题。<br>所谓适应性自旋锁意味着自旋的次数不再固定，它会由<strong>上一次</strong>锁的自旋时间及锁的拥有者的<strong>状态</strong>来决定。如果线程自旋成功了，那么虚拟机会认为再次自旋成功的概率更大，那么虚拟机就会<strong>增加</strong>自旋次数，允许自旋等待的持续时间更久；反之，如果某个锁很少能够自旋成功的，那么以后获取这个锁的时候自旋次数会<strong>减少</strong>甚至直接忽略掉自旋过程，以免浪费处理器资源。</p>
<hr>
<h1 id="锁消除与逃逸分析"><a href="#锁消除与逃逸分析" class="headerlink" title="锁消除与逃逸分析"></a>锁消除与逃逸分析</h1><hr>
<p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但有时候并没有存在<strong>共享数据竞争</strong>（竞态条件），<code>JVM</code>会对这些同步锁进行<strong>锁消除</strong>。锁消除的依据是<strong>逃逸分析</strong>后得到的数据。<br>关于逃逸分析的概念本文不过多展开，简单的说，逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可以被外部方法所引用，例如作为调用参数传递到其他地方中，称为<strong>方法逃逸</strong>。<br>比如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在使用<code>stringBuffer</code>时，并没有将<code>StringBUffer</code>的实例返回。如果将<code>sb</code>返回，那么它虽然时个<strong>局部变量</strong>，但也有可能被其他的方法所调用，称其为<strong>逃逸</strong>到了<strong>方法外部</strong>；甚至还有可能被其他的线程所调用，比如赋值给类变量或可以在其他线程中访问的实例变量，称其为<strong>线程逃逸</strong>。<br>上述代码只返回了<code>sb.toString()</code>,显然没有发生逃逸，不存在竞态条件，此时<code>StringBuffer</code>内部的加锁毫无意义，<code>JVM</code>可以大胆的将锁消除，以避免浪费无意义的请求锁的时间。</p>
<article class="message is-info"><div class="message-body">
<p>参考资料：<br>[1]《深入理解java虚拟机》<br>[2]《Java并发编程的艺术》<br>[3]《Java并发编程实战》</p>
</div></article></div><div class="article-licensing box"><div class="licensing-title"><p>深入理解synchronized</p><p><a href="https://lehan1125.github.io/2019/01/17/2019-01-17-JavaSynchronized/">https://lehan1125.github.io/2019/01/17/2019-01-17-JavaSynchronized/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Lehan</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-01-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-01-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/10/31/first-artic/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Test</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "658b4242a20d2347a5991034e1082f19",
            repo: "lehan1125.github.io",
            owner: "lehan1125",
            clientID: "39e4bcf8f94d26c612d0",
            clientSecret: "01159672c012cefa921d988fd7fb39de9748d94f",
            admin: ["lehan1125"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-30T16:25:08.748Z">2021-10-31</time></p><p class="title"><a href="/2021/10/31/hello-world/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-10-31T14:21:35.000Z">2019-10-31</time></p><p class="title"><a href="/2019/10/31/first-artic/">Test</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2019/01/17/2019-01-17-JavaSynchronized/"><img src="https://images.pexels.com/photos/355465/pexels-photo-355465.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500" alt="深入理解synchronized"></a></figure><div class="media-content"><p class="date"><time dateTime="2019-01-17T11:33:21.000Z">2019-01-17</time></p><p class="title"><a href="/2019/01/17/2019-01-17-JavaSynchronized/">深入理解synchronized</a></p></div></article></div></div><!--!--><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Lehan&#039;s blog</a><p class="is-size-7"><span>&copy; 2021 Lehan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>